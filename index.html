<!doctype html>
<html class="no-js" lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mjolnir Visualizer</title>
    <link rel="stylesheet" href="css/foundation.css">
    <link rel="stylesheet" href="css/app.css">

    <script src="lib/three.min.js"></script>
    <script src="lib/stats.min.js"></script>
    <script src="lib/Coordinates.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script src="lib/OBJLoader.js"></script>
    <script src="lib/dat.gui.min.js"></script>

  </head>
  <body>

  <script type="text/x-glsl" id="vertex">
		varying vec3 transformedNormal;
		varying vec3 pointPosition;

		varying vec3 lightVector1;
		uniform vec3 pointLightPosition1;

		varying vec3 lightVector2;
		uniform vec3 pointLightPosition2;

		varying vec3 lightVector3;
		uniform vec3 pointLightPosition3;

		varying vec3 lightVector4;
		uniform vec3 pointLightPosition4;

		void main()
		{
			transformedNormal = normalMatrix * normal;
			pointPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;

			//Info prima luce
			vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
			lightVector1 = lPosition1.xyz - pointPosition;

			//Info seconda luce
			vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
			lightVector2 = lPosition2.xyz - pointPosition;

			//Info terza luce
			vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );
			lightVector3 = lPosition3.xyz - pointPosition;

			//Info quarta luce
			vec4 lPosition4 = viewMatrix * vec4( pointLightPosition4, 1.0 );
			lightVector4 = lPosition4.xyz - pointPosition;

			gl_Position = projectionMatrix * vec4(pointPosition,1.0);
		}
		</script>

  <script type="text/x-glsl" id="fragment">
			uniform vec3 lightPower;
			uniform vec3 c_spec; // surface specular color: equal to F(0)
			uniform float alpha; // material roughness (increase for rougher surface)

			varying vec3 transformedNormal;
			varying vec3 pointPosition;

			varying vec3 lightVector1;
			varying vec3 lightVector2;
			varying vec3 lightVector3;
			varying vec3 lightVector4;

			#define PI 3.14159265

			// compute the geometry term
			float G(float LdotH)
			{
				return 1.0/pow(LdotH,2.0);
			}

			// compute Fresnel reflection term with Schlick approximation
			vec3 F(float LdotH) {
				return c_spec + (vec3(1.0) - c_spec)*pow(1.0-LdotH, 5.0);
			}

			// compute the normal distribution function, based on Trowbridge-Reitz
			float D(float NdotH){
				float A = pow(alpha,2.0);
				float B = PI * pow(pow(NdotH,2.0)*(A-1.0) + 1.0, 2.0);
				return A/B;
			}

			void main()
			{
				vec3  n      		 	= normalize( transformedNormal );
				vec3  v         		= normalize( -pointPosition );

				vec3  l1         		= normalize(  lightVector1 );
				vec3  l2                = normalize(  lightVector2 );
				vec3  l3                = normalize(  lightVector3 );
				vec3  l4                = normalize(  lightVector4 );

				vec3  h1         		= normalize(v  + l1 );
				vec3  h2                = normalize(v  + l2 );
				vec3  h3                = normalize(v  + l3 );
				vec3  h4                = normalize(v  + l4 );

				float  NdotH1    		= max(0.000001, dot( n, h1 ));
				float  VdotH1     		= max(0.000001, dot( v, h1 ));
				float  NdotV 			= max(0.000001, dot( n, v  ));
				float  NdotL1 			= max(0.000001, dot( n, l1 ));

				float  NdotH2    		= max(0.000001, dot( n, h2 ));
				float  VdotH2     		= max(0.000001, dot( v, h2 ));
				float  NdotL2 			= max(0.000001, dot( n, l2 ));

				float  NdotH3    		= max(0.000001, dot( n, h3 ));
				float  VdotH3     		= max(0.000001, dot( v, h3 ));
				float  NdotL3 			= max(0.000001, dot( n, l3 ));

				float  NdotH4    		= max(0.000001, dot( n, h4 ));
				float  VdotH4     		= max(0.000001, dot( v, h4 ));
				float  NdotL4 			= max(0.000001, dot( n, l4 ));

				// specular BRDF1
				vec3 Specular1 = F(VdotH1) * G(VdotH1) * D(NdotH1) / 4.0;
				vec3 beta1 = lightPower / ( 4.0  * PI * pow( length(lightVector1),2.0) );

				// specular BRDF2
				vec3 Specular2 = F(VdotH2) * G(VdotH2) * D(NdotH2) / 4.0;
				vec3 beta2 = lightPower / ( 4.0  * PI * pow( length(lightVector2),2.0) );

				// specular BRDF3
				vec3 Specular3 = F(VdotH3) * G(VdotH3) * D(NdotH3) / 4.0;
				vec3 beta3 = lightPower / ( 4.0  * PI * pow( length(lightVector3),2.0) );

				// specular BRDF4
				vec3 Specular4 = F(VdotH4) * G(VdotH4) * D(NdotH4) / 4.0;
				vec3 beta4 = lightPower / ( 4.0  * PI * pow( length(lightVector4),2.0) );

				//Colore del Frammento considerando tutte le luci
				gl_FragColor = vec4(beta1 * NdotL1 * Specular1, 1.0) +
							   vec4(beta2 * NdotL2 * Specular2, 1.0) +
							   vec4(beta3 * NdotL3 * Specular3, 1.0) +
							   vec4(beta4 * NdotL4 * Specular4, 1.0);

			}
		</script>

        <script type="text/x-glsl" id="vertex_combined">
            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
                vPosition = vPos.xyz;
                vNormal = normalMatrix * normal;
                gl_Position = projectionMatrix * vPos;
            }
		</script>

		<script type="text/x-glsl" id="fragment_combined">
			varying vec3 vNormal;
			varying vec3 vPosition;

			uniform vec3 pointLightPosition; // in world space
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;
			uniform vec3 pointLightPosition4;

			uniform vec3 clight;
			uniform vec3 cspec;
			uniform vec3 cdiff;
			uniform float roughness;
			const float PI = 3.14159;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2,1.0 );
				vec4 lPosition3 = viewMatrix * vec4(pointLightPosition3,1.0 );
				vec4 lPosition4 = viewMatrix * vec4(pointLightPosition4,1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2= normalize(lPosition2.xyz- vPosition.xyz);
				vec3 l3= normalize(lPosition3.xyz- vPosition.xyz);
				vec3 l4= normalize(lPosition4.xyz- vPosition.xyz);

				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				vec3 v = normalize( -vPosition);

				vec3 h  = normalize( v + l );
				vec3 h2 = normalize( v + l2);
                vec3 h3 = normalize( v + l3);
                vec3 h4 = normalize( v + l4);

				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				float nDotl2 = max(dot( n, l2 ),0.000001);
				float lDoth2 = max(dot( l2, h2),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);

				float nDotl3 = max(dot( n, l3 ),0.000001);
				float lDoth3 = max(dot( l3, h3),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotl4 = max(dot( n, l4 ),0.000001);
				float lDoth4 = max(dot( l4, h4),0.000001);
				float nDoth4 = max(dot( n, h4 ),0.000001);
				float vDoth4 = max(dot( v, h4 ),0.000001);

				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);

				vec3 fresnel2 = FSchlick(lDoth2);
				vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);

                vec3 fresnel3 = FSchlick(lDoth3);
				vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

                vec3 fresnel4 = FSchlick(lDoth4);
				vec3 BRDF4 = (vec3(1.0)-fresnel4)*cdiff/PI + fresnel4*GSmith(nDotv,nDotl4)*DGGX(nDoth4,roughness*roughness)/(4.0*nDotl4*nDotv);


				vec3 outRadiance = (PI* clight * nDotl * BRDF)  +
				                   (PI* clight * nDotl2 * BRDF2)+
				                   (PI* clight * nDotl3 * BRDF3)+
				                   (PI* clight * nDotl4 * BRDF4);
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

  <script type="text/x-glsl" id="vertex_texture">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

  <script type="text/x-glsl" id="fragment_texture">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space
            uniform vec3 pointLightPosition2;
            uniform vec3 pointLightPosition3;
			uniform vec3 clight;
			uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D roughnessMap;
			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			vec3 cdiff;
			vec3 cspec;
			float roughness;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
                vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
                vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
                vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				vec3 v = normalize( -vPosition);

				vec3 h  = normalize( v +  l);
                vec3 h2 = normalize( v + l2);
                vec3 h3 = normalize( v + l3);

				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
                float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);

                float nDotl2 = max(dot( n, l2 ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
                float nDoth2 = max(dot( n, h2 ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
                
                float nDotl3 = max(dot( n, l3 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);
                float nDoth3 = max(dot( n, h3 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cspec = pow( cspec, vec3(2.2));
				roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);

                vec3 fresnel2 = FSchlick(lDoth2);
                vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
                (4.0*nDotl2*nDotv);

                vec3 fresnel3 = FSchlick(lDoth3);
                vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
                (4.0*nDotl3*nDotv);
                
				vec3 outRadiance = (PI* clight * nDotl * BRDF) + 
                                   (PI* clight * nDotl2 * BRDF2) + 
                                   (PI* clight * nDotl3 * BRDF3);
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

          <script type="text/x-glsl" id="vertex_refraction">
                varying vec3 vReflect;

                void main()
                {
                    vec4 worldPosition = modelMatrix * vec4(position,1.0);
                    vec4 worldNormal = modelMatrix * vec4(normal,0.0);
                    vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
                    vReflect = refract( normalize( worldPosition.xyz - cameraPosition ), normalize( worldNormal.xyz ), 1.0/2.0 );
                    gl_Position = projectionMatrix * viewMatrix * worldPosition;
                }
          </script>

          <script type="text/x-glsl" id="fragment_refraction">
                varying vec3 vReflect;
                uniform samplerCube tReflection;

                void main()
                {
                    gl_FragColor = textureCube( tReflection,vReflect);
                }
		</script>

  <div class="top-bar">
      <div class="top-bar-left">
          <ul class="menu"> 
               <li><img src="media/acme-logo.png" alt="Uniud Logo"/></li>
              <li class="menu-text">Mjolnir Visualizer</li>
          </ul>
      </div>
      <div class="top-bar-right">
          <ul class="menu">
              <li><button type="button" class="button alert">Buy Now!</button></li>
          </ul>
      </div>
  </div>

  <div class="row">
      <div class="large-2 medium-2 small-2 columns" id="mymenu">
          <ul class="menu vertical" >
              <br />
              <li class="menu-text">Customize</li>
              <br />
              <p id="hint">( Default is Metallic Mjolnir )</p>
              <li><a class="button expanded" href="javascript:click_show_used()">Used Mjolnir</a></li>
              <br />
              <li><a class="button expanded" href="javascript:click_show_toy()">Mjolnir Toy</a></li>
              <br />
              <li><a class="button expanded" href="javascript:click_show_metallic()">Metallic Mjolnir</a></li>
              <br />
              <li><a class="button expanded" href="javascript:click_show_enviroment()">Invisible Mjolnir</a></li>
              <br />
              <li><p id="show">See it in space!</p></li>
              <li>
                <div id="move" class="switch medium">
                    <input class="switch-input" id="yes-no" type="checkbox" name="exampleSwitch" onclick="Space();">
                    <label class="switch-paddle" for="yes-no">
                        <span class="show-for-sr">See it in space!</span>
                        <span class="switch-active" aria-hidden="true">On</span>
                        <span class="switch-inactive" aria-hidden="true">Off</span>
                    </label>
                </div>
              </li>
          </ul>
        </div>
        <div class="large-10 medium-10 small-10 columns ">
                <canvas class="large-10 medium-10 small-10 columns " id="threejs" width="1024" height="576" ></canvas>
        </div>
  </div>

    <div class="row">
        <br />
        <br />        
        <p>
            Forse potrebbe interessarti anche..<a href=""> More here! </a>
        </p>
         
    </div>

    <div id="foot" >
            <p>Made by: David La Barbera</p>
    </div>


  <script>

      window.addEventListener( 'resize', onWindowResize, false );

      var scene, camera, renderer, controls, stats, loader;

      //variabili che mi consentono di rimuovere il precedente modello all'occorrenza
      var selected_object = null;

      //Variabili per ascoltare il click dei pulsanti
      var click_metallico = false;
      var click_giocattolo = false;
      var click_enviroment = false;
      var click_used_hammer = false;

      //variabile per vedere il particle system
      var is_on = false;

      var is_refract = false;

      scene = new THREE.Scene();

    //Prendo l'elemento che fungerà da contenitore al mio renderer tramite il suo id
      var container = document.getElementById("threejs");
      renderer = new THREE.WebGLRenderer( {canvas: threejs, antialias: true} );

      camera = new THREE.PerspectiveCamera( 75, container.width / container.height, 0.1, 1000 );

    //Adatto le dimensioni del renderer a quelle del canvas usato
      renderer.setSize( container.width, container.height );

    //Imposto correttamente la posizione nella finestra del renderer
      renderer.domElement.style.position = 'absolute';
      renderer.domElement.style.top = '80px';
        if(window.innerWidth > 1800){
            renderer.domElement.style.left = '500px';
        }else{
            renderer.domElement.style.left = '220px';
        }
      renderer.setClearColor( 0xf1f3f4 );
      document.body.appendChild( renderer.domElement );

    //Posizionamento Camera
      camera.position.set(40, 20, 30);
      camera.lookAt( new THREE.Vector3(0,0,0));

    //Setup shader uniforms
      //Metallic Version
    var uniformsGold = {
      c_spec:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition1:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
      lightPower:	{ type: "v3", value: new THREE.Vector3() },
      alpha: {type: "f", value: 0}
    };
    var uniformsSilver = {
      c_spec:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition1:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
      lightPower:	{ type: "v3", value: new THREE.Vector3() },
      alpha: {type: "f", value: 0}
    };
    var uniformsUsed = {
      c_spec:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition1:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
      pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
      lightPower:	{ type: "v3", value: new THREE.Vector3() },
      alpha: {type: "f", value: 0}
    };

            //Texture data
        var uniforms_texture = {
            specularMap: { type: "t", value: specularMap},
            diffuseMap:	{ type: "t", value: diffuseMap},
            roughnessMap:	{ type: "t", value: roughnessMap},
            pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
            pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
            pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
            clight:	{ type: "v3", value: new THREE.Vector3() },
            textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) }
        };

        var uniforms_concrete = {
            specularMap: { type: "t", value: specularMap_concrete},
            diffuseMap:	{ type: "t", value: diffuseMap_concrete},
            roughnessMap:	{ type: "t", value: roughnessMap_concrete},
            pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
            pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
            pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
            clight:	{ type: "v3", value: new THREE.Vector3() },
            textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) }
        }

        var diffuseMap = loadTexture( "media/Wood_StaggeredFloorPlanks_Diffuse.png" );
        var specularMap = loadTexture( "media/Wood_StaggeredFloorPlanks_Specular.png" );
        var roughnessMap = loadTexture( "media/Wood_StaggeredFloorPlanks_Roughness.png" );

        var diffuseMap_concrete = loadTexture( "media/Concrete_ChunkybrokenWall_Diffuse.png" );
        var specularMap_concrete = loadTexture( "media/Concrete_ChunkybrokenWall_Specular.png" );
        var roughnessMap_concrete = loadTexture( "media/Concrete_ChunkybrokenWall_Roughness.png" );

        var vs_t = document.getElementById("vertex_texture").textContent;
        var fs_t = document.getElementById("fragment_texture").textContent;

        var texture_material = new THREE.ShaderMaterial({ uniforms: uniforms_texture, vertexShader: vs_t, fragmentShader: fs_t });
        var concrete_texture_material = new THREE.ShaderMaterial({ uniforms: uniforms_concrete, vertexShader: vs_t, fragmentShader: fs_t });

    var vs = document.getElementById("vertex").textContent;
    var fs = document.getElementById("fragment").textContent;

    var vsc = document.getElementById("vertex_combined").textContent;
	var fsc = document.getElementById("fragment_combined").textContent;

      //Metallic Materials
    var gold_material = new THREE.ShaderMaterial({ uniforms: uniformsGold, vertexShader: vs, fragmentShader: fs });
    var silver_material = new THREE.ShaderMaterial({ uniforms: uniformsSilver, vertexShader: vs, fragmentShader: fs});
    var used_material = new THREE.ShaderMaterial({ uniforms: uniformsUsed, vertexShader: vs, fragmentShader: fs});

      //On start default visualization
    Metallic_Hammer();

    //Geometria e Materiale per le luci
    geometryLight = new THREE.SphereGeometry( 0.05, 0.05, 0.05);
      //materiale invisibile cosicchè non si vedano le fonti di luce
    materialLight = new THREE.MeshBasicMaterial( { transparent: true, opacity: 0 } )

    //Setup luci scena su ogni materiale
    //Prima Luce
    lightA = new THREE.Mesh( geometryLight, materialLight);
    lightA.position.set( 0.0, 1.0, 13.0 );
    scene.add( lightA );

    uniformsGold.pointLightPosition1.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
    uniformsSilver.pointLightPosition1.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
    uniformsUsed.pointLightPosition1.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);

      //Seconda Luce
    lightB = new THREE.Mesh( geometryLight, materialLight);
    lightB.position.set( 0, 15.0, 0.0 );
    scene.add( lightB );

    uniformsGold.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
    uniformsSilver.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
    uniformsUsed.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);


      //Terza Luce
    lightC = new THREE.Mesh( geometryLight, materialLight);
    lightC.position.set( 0.0, 1.0, -13.0 );
    scene.add( lightC );

    uniformsGold.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
    uniformsSilver.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
    uniformsUsed.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);


      //Quarta Luce
    lightD = new THREE.Mesh( geometryLight, materialLight);
    lightD.position.set( -18.0, -5.0, 0.0 );
    scene.add( lightD );

    uniformsGold.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);
    uniformsSilver.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);
    uniformsUsed.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);

      //Setup uniforms
    uniformsGold.c_spec.value = new THREE.Vector3( 1.0, 0.79, 0.29 );
    uniformsGold.lightPower.value = new THREE.Vector3( 5000.0, 5000.0, 5000.0 );
    uniformsGold.alpha.value = 0.4;

    uniformsSilver.c_spec.value = new THREE.Vector3( 0.8, 0.8, 0.8 );
    uniformsSilver.lightPower.value = new THREE.Vector3( 6000.0, 6000.0, 6000.0 );
    uniformsSilver.alpha.value = 0.4;

    uniformsUsed.c_spec.value = new THREE.Vector3( 0.15, 0.55, 0.99 );
    uniformsUsed.lightPower.value = new THREE.Vector3( 6000.0, 6000.0, 6000.0 );
    uniformsUsed.alpha.value = 0.4;

    uniforms_texture.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
    uniforms_texture.pointLightPosition2.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
    uniforms_texture.pointLightPosition3.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);
    uniforms_texture.clight.value = new THREE.Vector3(1.0, 1.0, 1.0);
    uniforms_texture.textureRepeat.value = new THREE.Vector2( 1.0, 1.0);
    uniforms_texture.diffuseMap.value = diffuseMap;
    uniforms_texture.specularMap.value = specularMap;
    uniforms_texture.roughnessMap.value = roughnessMap;
    uniforms_texture.textureRepeat.value = new THREE.Vector2(0.05, 0.05);

    uniforms_concrete.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
    uniforms_concrete.pointLightPosition2.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
    uniforms_concrete.pointLightPosition3.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);
    uniforms_concrete.clight.value = new THREE.Vector3(1.0, 1.0, 1.0);
    uniforms_concrete.textureRepeat.value = new THREE.Vector2( 1.0, 1.0);
    uniforms_concrete.diffuseMap.value = diffuseMap_concrete;
    uniforms_concrete.specularMap.value = specularMap_concrete;
    uniforms_concrete.roughnessMap.value = roughnessMap_concrete;
    uniforms_concrete.textureRepeat.value = new THREE.Vector2(0.1, -0.1);

    SetupOrbitControls();

      function SetupOrbitControls() {
          controls = new THREE.OrbitControls( camera );
          controls.addEventListener( 'change', Render );
          //Limito la distanza a cui posso andare dall'oggetto per evitare attraversamenti
          controls.minDistance = 18;
          controls.maxDistance = 100;
          //limito l'angolo di rotazione così da non poter andare sotto al materiale;
          controls.minPolarAngle = 0;
          controls.maxPolarAngle = Math.PI/2;

          controls.enablePan = false;
      }

    function Update() {
      requestAnimationFrame( Update );
        //Se clickBase è true allora visualizzo la base
        if(click_used_hammer){
            TextureHammer();
            click_used_hammer = false;
        }
        if(click_metallico){
            Metallic_Hammer();
            click_metallico = false;
        }
        if(click_giocattolo){
            SetupToyHammer();
            click_giocattolo = false;
        }
        if(click_enviroment){
            ShowEnviroment();
            click_enviroment = false;
        }

      controls.update();
      Render();
    }

    function Render() {
      renderer.render(scene, camera);
    }


      function onWindowResize(){
          //Se le dimensioni della finestra diventano eccessive
          //sposto il canvas per non coprire il menù
          if(window.innerWidth > 1400){
              renderer.domElement.style.left = '500px';
          }else{
              renderer.domElement.style.left = '190px';
          }

      }

      function click_show_used(){
          click_used_hammer = true;
      }

      //Funzione che ascolta il click sul pulsante metallic mjolnir
      function click_show_metallic() {
          click_metallico = true;
      }

      //Funzione per l'ascolto del pulsante toy
      function click_show_toy() {
          click_giocattolo = true;
      }

      function click_show_enviroment(){
          click_enviroment = true;
      }

      //Funzione per visualizzare la versione metallica del martello
      function Metallic_Hammer() {
            //Se sto visualizzando un martello allora lo elimino e inserisco quello nuovo;
           adjustBackground();

          var childCounter = 0;
          var loader = new THREE.OBJLoader();
          loader.load( 'models/hammer.obj', function ( object ) {
                object.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                   if(childCounter == 0) {
                         child.material = silver_material;
                   }
                   else if(childCounter == 1) {
                         child.material = silver_material;
                   }
                   else if(childCounter == 2) {
                         child.material = texture_material;
                   }
                   else if(childCounter == 14){
                       child.material = texture_material;
                   }
                   else if(childCounter == 16){
                       child.material = silver_material;
                   }
                   else{
                         child.material = gold_material;
                   }
                   childCounter++;
                }
              } );
              scene.add(object);
              //Ridimensiono e ruoto
              object.scale.set(0.2, 0.2, 0.2);
              object.rotation.z = -(45 * Math.PI/180);
              selected_object = object;
          } );
      }

      function SetupToyHammer(){

           adjustBackground();

          //Gomma rossa
          var first_materialParameters = {
				cdiff_red: 0.5,
				cdiff_green: 0.0,
				cdiff_blue: 0.0,
				cspec_red: 0.04,
				cspec_green: 0.04,
				cspec_blue: 0.04,
				roughness: 0.3
			}

            var second_materialParameters = {
				cdiff_red: 0.2,
				cdiff_green: 0.2,
				cdiff_blue: 0.2,
				cspec_red: 0.04,
				cspec_green: 0.04,
				cspec_blue: 0.04,
				roughness: 0.1
			}

            var decorationParameters = {
				cdiff_red: 0.0,
				cdiff_green: 0.0,
				cdiff_blue: 0.7,
				cspec_red: 0.04,
				cspec_green: 0.04,
				cspec_blue: 0.04,
				roughness: 0.4
			}

			var uniformsToy = {
						cspec:	{ type: "v3", value: new THREE.Vector3() },
						cdiff:	{ type: "v3", value: new THREE.Vector3() },
						roughness: {type: "f", value: 0.5},
						pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
						clight:	{ type: "v3", value: new THREE.Vector3() },
					};

            var uniformsToy2 = {
						cspec:	{ type: "v3", value: new THREE.Vector3() },
						cdiff:	{ type: "v3", value: new THREE.Vector3() },
						roughness: {type: "f", value: 0.5},
						pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
						clight:	{ type: "v3", value: new THREE.Vector3() },
					};

            var uniformsDecoration = {
						cspec:	{ type: "v3", value: new THREE.Vector3() },
						cdiff:	{ type: "v3", value: new THREE.Vector3() },
						roughness: {type: "f", value: 0.5},
						pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
                        pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
						clight:	{ type: "v3", value: new THREE.Vector3() },
					};

            RubberMaterial = new THREE.ShaderMaterial({ uniforms: uniformsToy, vertexShader: vsc, fragmentShader: fsc });
            SecondToyMaterial = new THREE.ShaderMaterial({ uniforms: uniformsToy2, vertexShader: vsc, fragmentShader: fsc });
            DecorationMaterial = new THREE.ShaderMaterial({ uniforms: uniformsDecoration, vertexShader: vsc, fragmentShader: fsc });

             var childCounter = 0;
                var loader = new THREE.OBJLoader();
                loader.load( 'models/hammer.obj', function ( object ) {
                        object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            if(childCounter == 0) {
                                    child.material = RubberMaterial;
                            }
                            else if(childCounter == 1) {
                                    child.material = RubberMaterial;
                            }
                            else if(childCounter == 2) {
                                    child.material = DecorationMaterial;
                            } else if(childCounter == 14){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 16){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 17){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 18){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 19){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 20){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 21){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 22){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 23){
                                    child.material = DecorationMaterial;
                            }
                            else if(childCounter == 24){
                                    child.material = DecorationMaterial;
                            }
                            else{
                                    child.material = SecondToyMaterial;
                            }
                            childCounter++;
                        }
                    } );
                    scene.add(object);
                    //Ridimensiono e ruoto
                    object.scale.set(0.2, 0.2, 0.2);
                    object.rotation.z = -(45 * Math.PI/180);
                    selected_object = object;
                } );

        uniformsToy.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
        uniformsToy.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
        uniformsToy.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
        uniformsToy.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);

        uniformsToy.cspec.value = new THREE.Vector3(first_materialParameters.cspec_red, first_materialParameters.cspec_green, first_materialParameters.cspec_blue);
        uniformsToy.cdiff.value = new THREE.Vector3(first_materialParameters.cdiff_red, first_materialParameters.cdiff_green, first_materialParameters.cdiff_blue);
        uniformsToy.roughness.value = first_materialParameters.roughness>0.0?first_materialParameters.roughness:0.01;
        uniformsToy.clight.value = new THREE.Vector3(1.0, 1.0, 1.0);

        uniformsToy2.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
        uniformsToy2.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
        uniformsToy2.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
        uniformsToy2.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);

        uniformsToy2.cspec.value = new THREE.Vector3(second_materialParameters.cspec_red, second_materialParameters.cspec_green, second_materialParameters.cspec_blue);
        uniformsToy2.cdiff.value = new THREE.Vector3(second_materialParameters.cdiff_red, second_materialParameters.cdiff_green, second_materialParameters.cdiff_blue);
        uniformsToy2.roughness.value = second_materialParameters.roughness>0.0?second_materialParameters.roughness:0.01;
        uniformsToy2.clight.value = new THREE.Vector3(1.0, 1.0, 1.0);

        uniformsDecoration.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
        uniformsDecoration.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
        uniformsDecoration.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
        uniformsDecoration.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);

        uniformsDecoration.cspec.value = new THREE.Vector3(decorationParameters.cspec_red, decorationParameters.cspec_green, decorationParameters.cspec_blue);
        uniformsDecoration.cdiff.value = new THREE.Vector3(decorationParameters.cdiff_red, decorationParameters.cdiff_green, decorationParameters.cdiff_blue);
        uniformsDecoration.roughness.value = decorationParameters.roughness>0.0?decorationParameters.roughness:0.01;
        uniformsDecoration.clight.value = new THREE.Vector3(1.0, 1.0, 1.0);
      }
      
      function ShowEnviroment() {
            //Appena attivo il particle system da qui
            if(!is_on){
                if(selected_object != null){
                    scene.remove(selected_object);
                }

                var loader = new THREE.CubeTextureLoader();
                loader.setPath( 'media/' );

                var textureCube = loader.load( [
                    'posx.jpg', 'negx.jpg',
                    'posy.jpg', 'negy.jpg',
                    'posz.jpg', 'negz.jpg'
                ] );

                scene.background = textureCube;

                var uniforms_ref = { tReflection: { type: "t", value: textureCube } };

                var vs_r = document.getElementById("vertex_refraction").textContent;
                var fs_r = document.getElementById("fragment_refraction").textContent;

                var material_r = new THREE.ShaderMaterial({ uniforms: uniforms_ref, vertexShader: vs_r, fragmentShader: fs_r });

                    var loader = new THREE.OBJLoader();
                    loader.load( 'models/hammer.obj', function ( object ) {
                        object.traverse( function ( child ) {
                            if ( child instanceof THREE.Mesh ) {
                                child.material = material_r;
                            }
                        } );
                        scene.add(object);
                        //Ridimensiono e ruoto
                        object.scale.set(0.2, 0.2, 0.2);
                        object.rotation.z = -(45 * Math.PI/180);
                        selected_object = object;
                    } );
            }else{
                alert("Care, you can't go here from the particle system view!");
            }
      }

      function TextureHammer(){

           adjustBackground();
           var childCounter = 0;
                var loader = new THREE.OBJLoader();
                loader.load( 'models/hammer.obj', function ( object ) {
                        object.traverse( function ( child ) {
                        if ( child instanceof THREE.Mesh ) {
                            if(childCounter == 0) {
                                    child.material = used_material;
                            }
                            else if(childCounter == 1) {
                                    child.material = used_material;
                            }
                            else if(childCounter == 2) {
                                    child.material = concrete_texture_material;
                            } 
                            else if(childCounter == 14){
                                    child.material = concrete_texture_material;
                            }
                            else if(childCounter == 16){
                                    child.material = silver_material;
                            }
                            else if(childCounter == 17){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 18){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 19){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 20){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 21){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 22){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 23){
                                    child.material = gold_material;
                            }
                            else if(childCounter == 24){
                                    child.material = gold_material;
                            }
                            else{
                                    child.material = texture_material;
                            }
                            
                            childCounter++;
                        }
                    } );
                    
                    scene.add(object);
                    //Ridimensiono e ruoto
                    object.scale.set(0.2, 0.2, 0.2);
                    object.rotation.z = -(45 * Math.PI/180);
                    selected_object = object;
                } );

      }

      //Funzione per riutilizzare il codice ed evitare configurazioni di sfondo non consone
      function adjustBackground(){
        if(selected_object != null){
              scene.remove(selected_object);
          }
          if(!is_on){
             scene.background = new THREE.Color( 0xf1f3f4 );
          }
      }

      function loadTexture(file) {
          var texture = new THREE.TextureLoader().load( file , function ( texture ) {

              texture.minFilter = THREE.LinearMipMapLinearFilter;
              texture.anisotropy = renderer.getMaxAnisotropy();
              texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
              texture.offset.set( 0, 0 );
              texture.needsUpdate = true;
              Render();
          } )
          return texture;
      }

      function createParticleSystem() {
        scene.background = new THREE.Color( 0x000000 );
        var particles = new THREE.Geometry();
        for (var p = 0; p < 2000; p++) { 
            var particle = new THREE.Vector3(Math.random() * 500 - 250, 
                                             Math.random() * 500 - 250,
                                             Math.random() * 500 - 250);
            particles.vertices.push(particle);
        }
        var particleMaterial = new THREE.PointsMaterial(
                {color: 0xffffff, 
                size: 4,
                map: THREE.ImageUtils.loadTexture("media/snowflake.png"),
                transparent: true,
                });
        particleSystem = new THREE.Points(particles, particleMaterial);
        return particleSystem;  
    }
    
    function Space(){
        //Se mi trovo nella situazione con il cubeMapping mi riporto in una più consona
        if(is_refract){
            Metallic_Hammer();
        }
        //Ascolto lo switch e rispondo di conseguenza in relazione al valore di is_on
        if(!is_on){
            particleSystem = createParticleSystem();
            scene.add(particleSystem);
            is_on = true;
        }
        else{
            scene.remove(particleSystem);
            particleSystem = null;
            scene.background = new THREE.Color( 0xf1f3f4 );
            is_on = false;
        }
    }

      is_refract = true;

      Update();

  </script>
  </body>
</html>