<html>
	<head>
		<title>Mjolnir</title>
		<style>

		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="lib/OBJLoader.js"></script>
	    <script src="lib/dat.gui.min.js"></script>
	</head>
	<body>

		<script type="text/x-glsl" id="vertex">
		varying vec3 transformedNormal;
		varying vec3 pointPosition;

		varying vec3 lightVector1;
		uniform vec3 pointLightPosition1;

		varying vec3 lightVector2;
		uniform vec3 pointLightPosition2;

		varying vec3 lightVector3;
		uniform vec3 pointLightPosition3;

		varying vec3 lightVector4;
		uniform vec3 pointLightPosition4;

		void main()
		{
			transformedNormal = normalMatrix * normal;
			pointPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;

			//Info prima luce
			vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
			lightVector1 = lPosition1.xyz - pointPosition;

			//Info seconda luce
			vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
			lightVector2 = lPosition2.xyz - pointPosition;

			//Info terza luce
			vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );
			lightVector3 = lPosition3.xyz - pointPosition;

			//Info quarta luce
			vec4 lPosition4 = viewMatrix * vec4( pointLightPosition4, 1.0 );
			lightVector4 = lPosition4.xyz - pointPosition;

			gl_Position = projectionMatrix * vec4(pointPosition,1.0);
		}
		</script>
		
		<script type="text/x-glsl" id="fragment">
			uniform vec3 lightPower;
			uniform vec3 c_spec; // surface specular color: equal to F(0)
			uniform float alpha; // material roughness (increase for rougher surface)

			varying vec3 transformedNormal;
			varying vec3 pointPosition;

			varying vec3 lightVector1;
			varying vec3 lightVector2;
			varying vec3 lightVector3;
			varying vec3 lightVector4;

			#define PI 3.14159265	

			// compute the geometry term
			float G(float LdotH)
			{
				return 1.0/pow(LdotH,2.0);
			}

			// compute Fresnel reflection term with Schlick approximation
			vec3 F(float LdotH) {
				return c_spec + (vec3(1.0) - c_spec)*pow(1.0-LdotH, 5.0);
			}

			// compute the normal distribution function, based on Trowbridge-Reitz
			float D(float NdotH){
				float A = pow(alpha,2.0);
				float B = PI * pow(pow(NdotH,2.0)*(A-1.0) + 1.0, 2.0);
				return A/B;
			}

			void main()
			{
				vec3  n      		 	= normalize( transformedNormal );  
				vec3  v         		= normalize( -pointPosition );  

				vec3  l1         		= normalize(  lightVector1 ); 
				vec3  l2                = normalize(  lightVector2 );
				vec3  l3                = normalize(  lightVector3 );
				vec3  l4                = normalize(  lightVector4 );

				vec3  h1         		= normalize(v  + l1 );
				vec3  h2                = normalize(v  + l2 );
				vec3  h3                = normalize(v  + l3 );
				vec3  h4                = normalize(v  + l4 );

				float  NdotH1    		= max(0.000001, dot( n, h1 ));  
				float  VdotH1     		= max(0.000001, dot( v, h1 ));  
				float  NdotV 			= max(0.000001, dot( n, v  ));  
				float  NdotL1 			= max(0.000001, dot( n, l1 ));  

				float  NdotH2    		= max(0.000001, dot( n, h2 ));  
				float  VdotH2     		= max(0.000001, dot( v, h2 ));  
				float  NdotL2 			= max(0.000001, dot( n, l2 ));  

				float  NdotH3    		= max(0.000001, dot( n, h3 ));  
				float  VdotH3     		= max(0.000001, dot( v, h3 ));  
				float  NdotL3 			= max(0.000001, dot( n, l3 ));  

				float  NdotH4    		= max(0.000001, dot( n, h4 ));  
				float  VdotH4     		= max(0.000001, dot( v, h4 ));  
				float  NdotL4 			= max(0.000001, dot( n, l4 )); 

				// specular BRDF1
				vec3 Specular1 = F(VdotH1) * G(VdotH1) * D(NdotH1) / 4.0;
				vec3 beta1 = lightPower / ( 4.0  * PI * pow( length(lightVector1),2.0) );

				// specular BRDF2
				vec3 Specular2 = F(VdotH2) * G(VdotH2) * D(NdotH2) / 4.0;
				vec3 beta2 = lightPower / ( 4.0  * PI * pow( length(lightVector2),2.0) );

				// specular BRDF3
				vec3 Specular3 = F(VdotH3) * G(VdotH3) * D(NdotH3) / 4.0;
				vec3 beta3 = lightPower / ( 4.0  * PI * pow( length(lightVector3),2.0) );

				// specular BRDF4
				vec3 Specular4 = F(VdotH4) * G(VdotH4) * D(NdotH4) / 4.0;
				vec3 beta4 = lightPower / ( 4.0  * PI * pow( length(lightVector4),2.0) );

				//Colore del Frammento considerando tutte le luci
				gl_FragColor = vec4(beta1 * NdotL1 * Specular1, 1.0) +
							   vec4(beta2 * NdotL2 * Specular2, 1.0) +
							   vec4(beta3 * NdotL3 * Specular3, 1.0) +
							   vec4(beta4 * NdotL4 * Specular4, 1.0);
				
			}
		</script>

		<script type="text/x-glsl" id="vertex_texture_ice">
		varying vec3 transformedNormal;
		varying vec3 pointPosition;
		varying vec3 lightVector;
		varying vec2 uVv;
		uniform vec3 pointLightPosition;

		void main()
		{
			transformedNormal = normalMatrix * normal;
			pointPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;
			vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
			lightVector = lPosition.xyz - pointPosition;
			uVv = uv;
			gl_Position = projectionMatrix * vec4(pointPosition,1.0);
		}
		</script>
		
		<script type="text/x-glsl" id="fragment_texture_ice">
			uniform vec3 lightPower;
			uniform sampler2D specularMap; // surface specular color: equal to F(0)
			uniform sampler2D glossMap; // material roughness 
			uniform sampler2D diffuseMap; // surface diffuse color
			uniform float s; // ratio of diffuse lighting

			varying vec3 transformedNormal;
			varying vec3 pointPosition;
			varying vec3 lightVector;
			varying vec2 uVv;

			#define PI 3.14159265	

			// compute the geometry term
			float G(float LdotH)
			{
				return 1.0/pow(LdotH,2.0);
			}

			// compute Fresnel reflection term with Schlick approximation
			vec3 F(float LdotH) {
				vec3 c_spec = texture2D(specularMap,uVv).rgb;
				return c_spec + (1.0 - c_spec)*pow(1.0-LdotH, 5.0);
			}

			// compute the normal distribution function, based on Trowbridge-Reitz
			float D(float NdotH){
				float alpha = 1.0-texture2D(glossMap,uVv).r;
				float A = pow(alpha,2.0);
				float B = PI * pow(pow(NdotH,2.0)*(A-1.0) + 1.0, 2.0);
				return A/B;
			}

			void main()
			{
				vec3  n      		 	= normalize( transformedNormal );  
				vec3  v         		= normalize( -pointPosition );  
				vec3  l         		= normalize(  lightVector );  
				vec3  h          		= normalize( v+l );  
				float  NdotH    		= max(0.000001, dot( n, h ));  
				float  VdotH     		= max(0.000001, dot( v, h ));  
				float  NdotV 			= max(0.000001, dot( n, v ));  
				float  NdotL 			= max(0.000001, dot( n, l ));    
				// specular BRDF
				vec3 Specular = F(VdotH) * G(VdotH) * D(NdotH) / 4.0;
				vec3 beta = lightPower / ( 4.0  * PI * pow( length(lightVector),2.0) );
				vec3 c_diff = texture2D( diffuseMap, uVv).rgb;
				gl_FragColor = vec4(beta * NdotL * ( s*c_diff + (1.0-s)*Specular), 1.0);
			}
		</script>

		<script>

		var scene, camera, renderer, controls, stats, loader;

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xbdbdbd );
			document.body.appendChild( renderer.domElement );

			//Posizionamento Camera
			camera.position.set(60, 40, 40);
			camera.lookAt( new THREE.Vector3(0,0,0));

			//Setup shader uniforms
			var uniformsGold = {
						c_spec:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition1:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
						lightPower:	{ type: "v3", value: new THREE.Vector3() },
						alpha: {type: "f", value: 0}
					};
			var uniformsSilver = {
						c_spec:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition1:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition3:	{ type: "v3", value: new THREE.Vector3() },
						pointLightPosition4:	{ type: "v3", value: new THREE.Vector3() },
						lightPower:	{ type: "v3", value: new THREE.Vector3() },
						alpha: {type: "f", value: 0}
					};		
			
					
			var vs = document.getElementById("vertex").textContent;
			var fs = document.getElementById("fragment").textContent;
			
			var gold_material = new THREE.ShaderMaterial({ uniforms: uniformsGold, vertexShader: vs, fragmentShader: fs });
			var silver_material = new THREE.ShaderMaterial({ uniforms: uniformsSilver, vertexShader: vs, fragmentShader: fs});

			// Texture info setup
			
			var diffuseMap = THREE.ImageUtils.loadTexture( "media/Ice_Diffuse.png" );
			var specularMap = THREE.ImageUtils.loadTexture( "media/Ice_Specular.png" );
			var glossMap = THREE.ImageUtils.loadTexture( "media/Ice_Glossiness.png" );
			/*
			var diffuseMap = THREE.ImageUtils.loadTexture( "media/Metal_Diffuse.png" );
			var specularMap = THREE.ImageUtils.loadTexture( "media/Metal_Specular.png" );
			var glossMap = THREE.ImageUtils.loadTexture( "media/Metal_Glossiness.png" );
			*/
			diffuseMap.minFilter = THREE.LinearMipMapLinearFilter; diffuseMap.anisotropy = renderer.getMaxAnisotropy();
			specularMap.minFilter = THREE.LinearMipMapLinearFilter; specularMap.anisotropy = renderer.getMaxAnisotropy();
			glossMap.minFilter = THREE.LinearMipMapLinearFilter; glossMap.anisotropy = renderer.getMaxAnisotropy();
			
			var uniforms_texture = {
						specularMap: { type: "t", value: specularMap},
						diffuseMap:	{ type: "t", value: diffuseMap},
						glossMap:	{ type: "t", value: glossMap},
						pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
						lightPower:	{ type: "v3", value: new THREE.Vector3() },
						alpha: {type: "f", value: 0},
						s: {type: "f", value: 0},
					};
					
			var vs_t = document.getElementById("vertex_texture_ice").textContent;
			var fs_t = document.getElementById("fragment_texture_ice").textContent;

			var texture_material = new THREE.ShaderMaterial({ uniforms: uniforms_texture, vertexShader: vs_t, fragmentShader: fs_t });

			var childCounter = 0;
			var loader = new THREE.OBJLoader();
			loader.load( 'models/hammer.obj', function ( object ) {
				object.traverse( function ( child ) {
					if ( child instanceof THREE.Mesh ) {
						if(childCounter == 0) {
							child.material = silver_material;
						}
						else if(childCounter == 1) {
							child.material = silver_material;
						}
						else if(childCounter == 2) {
							child.material = silver_material;
						}
						else{
							child.material = gold_material;
						}
						child.geometry.computeVertexNormals();
						childCounter++;
					}
				} );
				scene.add(object);
				//Ridimensiono e ruoto
				object.scale.set(0.2, 0.2, 0.2);
				object.rotation.z = -(45 * Math.PI/180);
			} );
			

			//Posiziono la base che verrà visualizzata la maggior parte del tempo
			var geom = new THREE.CylinderGeometry( 25, 25, 0.05, 32 );
			var mesh = new THREE.Mesh( geom, texture_material );
			mesh.position.y = -9;
			scene.add( mesh );


			//Geometria e Materiale per le luci
			geometryLight = new THREE.SphereGeometry( 0.05, 0.05, 0.05);
			materialLight = new THREE.MeshBasicMaterial ({color: 0xffffff, wireframe:true});
			//Setup luci scena su ogni materiale
			//Prima Luce
			lightA = new THREE.Mesh( geometryLight, materialLight);
			lightA.position.set( 10.0, 4.0, 10.0 );
			scene.add( lightA );
			uniformsGold.pointLightPosition1.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
			uniformsSilver.pointLightPosition1.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
			//Seconda Luce
			lightB = new THREE.Mesh( geometryLight, materialLight);
			lightB.position.set( 0, 30.0, 0.0 );
			scene.add( lightB );
			uniformsGold.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
			uniformsSilver.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
			//Terza Luce
			lightC = new THREE.Mesh( geometryLight, materialLight);
			lightC.position.set( -10.0, 4.0, 10.0 );
			scene.add( lightC );
			uniformsGold.pointLightPosition3.value = new THREE.Vector3(lightC.position.x, lightC.position.y, lightC.position.z);
			uniformsSilver.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
			//Quarta Luce
			lightD = new THREE.Mesh( geometryLight, materialLight);
			lightD.position.set( 10.0, 4.0, -10.0 );
			scene.add( lightD );
			uniformsGold.pointLightPosition4.value = new THREE.Vector3(lightD.position.x, lightD.position.y, lightD.position.z);
			uniformsSilver.pointLightPosition2.value = new THREE.Vector3(lightB.position.x, lightB.position.y, lightB.position.z);
			//Setup uniforms			
			uniformsGold.c_spec.value = new THREE.Vector3( 1.0, 0.79, 0.29 );
			uniformsGold.lightPower.value = new THREE.Vector3( 9000.0, 9000.0, 9000.0 );
			uniformsGold.alpha.value = 0.5;

			uniformsSilver.c_spec.value = new THREE.Vector3( 0.8, 0.8, 0.8 );
			uniformsSilver.lightPower.value = new THREE.Vector3( 9000.0, 9000.0, 9000.0 );
			uniformsSilver.alpha.value = 0.5;

			//Texture uniforms data
			uniforms_texture.pointLightPosition.value = new THREE.Vector3(lightA.position.x, lightA.position.y, lightA.position.z);
			uniforms_texture.lightPower.value = new THREE.Vector3( 9000.0, 9000.0, 9000.0 );
			uniforms_texture.alpha.value = 0.9;
			uniforms_texture.s.value = 0.3;
			

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );
			//Limito la distanza a cui posso andare dall'oggetto per evitare attraversamenti
			controls.minDistance = 18;
			controls.minPolarAngle = 0;
			controls.maxPolarAngle = Math.PI/2;

			var params;
			var guiParameters = function() {
				this.alpha = 0.4;
			}
			params = new guiParameters();
				var gui = new dat.GUI();
				gui.add( params, "alpha", 0.0,7.0 );

		function Update() {
			requestAnimationFrame( Update );
			
			controls.update();
			stats.update();
			Render();
		}

		function Render() {
			renderer.render(scene, camera);
			uniformsGold.alpha.value = params.alpha;
		}

		Update();

		</script>
	</body>
</html>
